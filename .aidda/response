<think>
Okay, let's figure out why the bong_2 node is appearing in the DOT output when it shouldn't. The user mentioned that in the /tmp/ss.yaml input, the alt node has a path to "bar,bong" with a probability of 0.5. But in the generated graph, there's a disconnected bong_2 node. 

First, I need to look at how the code processes the paths. In the toAst function, when building hyperedges, the code splits the path keys by commas to handle multiple children. For each child name in the split list, it calls nodes.toAst(childName, nodeAst), which creates an Ast node for each child. Then, these children are added to the hyperedge's Children slice.

The problem might be that when "bar,bong" is split, both "bar" and "bong" are processed. However, in the YAML, the bong node doesn't have any paths defined, so it's a leaf. But in the alt node's path, "bar,bong" implies that both bar and bong are children under the same hyperedge. However, the bar node is already defined elsewhere and might be processed again here, leading to duplication. 

Wait, but in the YAML, the alt node's path is "bar,bong: 0.5". So when this path is processed, the code splits it into ["bar", "bong"], creating two children for the hyperedge. Each of these children is created by calling nodes.toAst, which would create new instances of bar and bong. However, the original bar node is already processed as part of the apple node's paths. This could lead to multiple instances of the bar node, which might not be intended. 

But in the Ast construction, each call to toAst with a name should create a new Ast node for that name, but in the code, the toAst function is called recursively. So when the alt node's path processes "bar", it creates another instance of the bar node, which might not be connected back to the main tree. This could result in a separate subtree starting from bar, which includes bong as a child, leading to the bong_2 node.

Wait, looking at the YAML, the bar node's paths are to bing and baz. So when the alt node's path creates a new bar node, that bar node would have its own paths to bing and baz, which would be processed, leading to their children. However, the original bar node (from apple's path) is already processed, so the new bar instance from alt's path would create another branch, leading to duplicate nodes. But since each node in the graph is created with a count suffix (like bar_1, bar_2), they appear as separate nodes. However, the bong node in the alt path's hyperedge would be a separate instance, leading to bong_2, which isn't connected elsewhere, hence appearing as disconnected.

The root cause is that when a node name is reused in a path (like bar in alt's path), the code creates a new instance of that node, leading to duplication. But in the YAML structure, each node is supposed to be unique by name. So processing the same node name multiple times in different paths would create separate Ast nodes, each with their own children, leading to disconnected subgraphs.

Wait, but in the YAML, each node is defined once. So when the code processes "bar" again in the alt's path, it should reference the same YAML node definition. However, the toAst function is called with the name "bar", which looks up the YAML node and creates a new Ast node each time. So even though the YAML node is the same, each reference to "bar" in different paths creates a separate Ast node. This leads to multiple instances of bar in the AST, each with their own children, causing the graph to have multiple bar nodes (bar_1, bar_2), and their children (like bong in bar's paths) would also be duplicated, leading to disconnected nodes like bong_2.

But according to the YAML, the bar node's paths are to bing and baz, not to bong. The bong node is only referenced in the alt node's path. So how does bong get into the graph? Let's trace:

- The alt node's path is "bar,bong: 0.5". When processing this, the code splits into "bar" and "bong". 

- For "bar", it creates a new Ast node for bar, which processes bar's paths (bing and baz). This bar instance is a separate node from the one created under apple. 

- For "bong", it creates an Ast node for bong, which has no paths, so it's a leaf. 

So the hyperedge under alt has two children: the new bar instance and the bong instance. The new bar instance would have its own children (bing and baz), but the bong instance has no children. 

However, in the original YAML, the alt node's path to "bar,bong" is intended to have both bar and bong as parallel children under the same probability. But since bar is already a node in the main tree (under apple -> bar), this creates a separate instance of bar under alt, leading to a disconnected subgraph starting from this new bar, and the bong under alt's hyperedge is another node, which isn't connected to anything else, hence appearing as bong_2.

The issue is that the code is creating multiple instances of the same node name when they are referenced in different paths, leading to disconnected nodes. The intended behavior might be that each node name refers to the same node in the AST, but the current code is treating each reference as a separate instance.

Looking at the toAst function: when it processes a child name, it calls nodes.toAst(childName, nodeAst), which creates a new Ast node each time, even if the childName has been processed before. This leads to duplicate nodes in the AST when the same name is referenced in multiple paths.

To fix this, the code should ensure that each node name is processed only once, and subsequent references to the same name reuse the existing Ast node. However, the current code's structure doesn't do that. Each time a node name is encountered in a path, a new Ast node is created, leading to duplication.

The solution would be to implement a memoization or cache in the toAst function so that each node name is processed only once, and subsequent calls return the existing Ast node. This way, all references to a node name point to the same Ast instance, preventing duplication and disconnected subgraphs.

Looking at the code for the toAst function:

func (nodes Nodes) toAst(name string, parent *Ast) (nodeAst *Ast) {
	node, ok := nodes[name]
	dieif(!ok, "missing node: %s", name)
	...
}

There's no caching here. Each call to toAst with the same name creates a new Ast node. So if "bar" is referenced multiple times in different paths, each reference creates a new Ast node for bar, leading to duplicates.

To fix this, we need to memoize the Ast nodes so that each name is processed only once. We can introduce a cache (a map) in the Nodes struct or pass a cache along during the toAst processing.

However, the current code's structure doesn't have a cache. So modifying the toAst function to use a cache would require adjusting the method signature or the Nodes struct to include a cache.

But the existing code's toAst function is a method on Nodes, and it's called recursively. To add memoization, we can create a helper function that uses a cache, perhaps by modifying the toAst method to check a cache before creating a new node.

Here's how to adjust the code:

1. Add a cache map[string]*Ast to the Nodes struct or pass it as a parameter to toAst.

But since Nodes is a map, we can't easily add a field. Alternatively, pass a cache map as an argument.

Modify the toAst function to accept a cache parameter:

func (nodes Nodes) toAst(name string, parent *Ast, cache map[string]*Ast) (nodeAst *Ast) {
    if cached, exists := cache[name]; exists {
        return cached
    }
    // process as before
    cache[name] = nodeAst
    return nodeAst
}

Then, in the initial call from ToAst, create the cache and pass it along.

But looking at the existing code:

func (nodes Nodes) ToAst() (roots []*Ast) {
	// get the root nodes (as a map)
	rootNodes := nodes.RootNodes()
	var rootNames []string
	for name := range rootNodes {
		rootNames = append(rootNames, name)
	}
	sort.Strings(rootNames)
	for _, name := range rootNames {
		root := nodes.toAst(name, nil)
		roots = append(roots, root)
	}
	return
}

The toAst method is called without a cache. So modifying the toAst function to use a cache would require adjusting all calls to include the cache.

So the plan is:

- Modify the toAst method to take a cache map[string]*Ast as an argument.
- Initialize the cache in the ToAst method and pass it to the first toAst call.
- Ensure that all recursive calls to toAst (when processing children) pass the same cache.

This way, each node is processed only once, and subsequent references to the same name return the cached Ast node.

In the current code, when processing the alt node's path "bar,bong", the code would check the cache for "bar" and "bong". If they've already been created (like "bar" from the apple path), it would reuse those instances. If not, it creates them and stores them in the cache.

This would prevent creating multiple instances of the same node, thus avoiding the duplication and disconnected nodes.

So the fix involves adding a cache to the toAst function to ensure each node is processed only once, regardless of how many times it's referenced in different paths.

Looking at the current code, the toAst function is called recursively when processing children. So adding a cache parameter to toAst and passing it along in recursive calls would solve the problem.

Let's adjust the code step by step:

1. Modify the toAst method to accept a cache map:

func (nodes Nodes) toAst(name string, parent *Ast, cache map[string]*Ast) (nodeAst *Ast) {
    // Check cache first
    if cached, exists := cache[name]; exists {
        return cached
    }
    // Proceed as before to create the node
    // ...
    // Store in cache before processing children
    cache[name] = nodeAst
    // Process children, passing the same cache
    for _, pathKey := range pathKeys {
        // ...
        for _, childName := range childNames {
            childAst := nodes.toAst(childName, nodeAst, cache)
            // ...
        }
    }
    return
}

2. In the ToAst method, initialize the cache and pass it:

func (nodes Nodes) ToAst() (roots []*Ast) {
    cache := make(map[string]*Ast)
    // ... existing code ...
    for _, name := range rootNames {
        root := nodes.toAst(name, nil, cache)
        roots = append(roots, root)
    }
    return
}

3. Ensure that all calls to toAst pass the cache. For example, in the loop where children are processed:

for _, childName := range childNames {
    childAst := nodes.toAst(childName, nodeAst, cache)
    hyperedge.Children = append(hyperedge.Children, childAst)
}

By introducing the cache, each node is created only once, even if referenced multiple times in different paths. This would prevent the creation of duplicate nodes like bar_2 and bong_2, ensuring that all references to the same node name point to the same Ast instance.

Testing this change with the given YAML, the alt node's path "bar,bong" would reference the existing bar node (from the apple path) and create a new bong node. Wait, but in the YAML, the bong node is only defined once. So the first time bong is referenced (in alt's path), it would be created and cached. Any subsequent references would reuse that instance. However, in the given YAML, bong is only referenced once in alt's path. So the bong node would be created once, and the hyperedge under alt would include the existing bar (from apple's path) and the new bong. But bar's paths are to bing and baz, which are processed once. This would connect bong under alt's hyperedge, but since bong has no children, it would be a leaf. However, in the original problem, the bong_2 node is disconnected, which suggests that the current code creates a separate instance of bong when processed under alt's path.

With the cache, when processing alt's path "bar,bong", the code would check the cache for bar and bong. The bar node was already created when processing apple's path, so it's reused. The bong node is not in the cache yet, so it's created and added to the cache. Then, when processing the alt's hyperedge, both bar (existing) and bong (new) are added as children. The bong node has no paths, so it's a leaf. The DOT output would include bong_1 (since it's the first instance) connected under alt's hyperedge. However, in the original problem, the user is seeing a bong_2 node, which suggests that without the cache, the code created two instances of bong. But in the YAML, bong is only referenced once. Wait, in the YAML, the alt node's path is "bar,bong: 0.5", which is the only reference to bong. So without the cache, each time alt's path is processed, it would create a new bong instance. But in the YAML, there's only one reference to bong, so why is there a bong_2?

Ah, perhaps because the code is processing the same node multiple times in different branches. For example, if another node references bong, it would create another instance. But in the given YAML, only alt references bong. So without the cache, each time the code processes alt's path, it creates a new bong instance. But in the YAML, the alt node is processed once, leading to one bong instance. However, if the code is processing the same node name multiple times in different hyperedges, it would create multiple instances. 

Wait, in the current code (without cache), when processing the alt node's path "bar,bong", the code processes bar and bong. The bar node is processed again, leading to a new instance of bar (bar_2), which in turn processes its own paths (bing and baz). But the bong node is processed once here, leading to bong_1. But the user is seeing a bong_2 node. That suggests that somewhere else, another instance of bong is being created. 

Wait, maybe in the code's Dot method, when generating the graphviz nodes, it uses the countNodesPrefixed function to append a suffix based on the number of existing nodes with the same prefix. So even if the Ast node is the same, the Dot method might create multiple nodes if the same Ast is processed multiple times. Wait, no: the Ast nodes are different instances, so each would have their own names, leading to different node names in the graphviz output. 

But the original issue is that the bong_2 node is present and disconnected. This implies that there are two Ast nodes for bong, each leading to their own graphviz nodes. But according to the YAML, bong is only referenced once in the alt node's path. Without the cache, each time the code processes the alt node's path, it creates a new bong Ast node. However, in the YAML, the alt node's path is processed once, leading to one bong instance. Unless there's another reference to bong elsewhere. 

Looking at the YAML provided:

The alt node has:

alt:
  desc: alternative
  days: 365
  paths:
    bar,bong: .5
    bing: .5

So the path "bar,bong" is split into two children: bar and bong. Each of these is processed with toAst, creating new Ast nodes for bar and bong. The bar node's paths are processed, leading to bing and baz. The bong node has no paths. 

However, the original bar node (from the apple path) has paths to bing and baz, but the bar instance created under alt's path would also have those paths, leading to another instance of bing and baz. This could cause duplicated nodes for bing and baz as well. 

But the user is specifically mentioning bong_2. So perhaps the code is generating two instances of bong. How?

Wait, in the YAML, the alt node's path is "bar,bong: 0.5" and another path "bing: 0.5". When processing the "bar,bong" hyperedge, the code creates a new bar and a new bong. The new bar's paths are processed, leading to new instances of bing and baz. The new bong is a leaf. Then, in the "bing" path of alt, the code creates a new bing instance (since there's no cache), leading to another bing node. However, the user's issue is about bong_2, which suggests that the bong node is being created twice. 

But according to the YAML, bong is only referenced once in the alt node's "bar,bong" path. So why is there a bong_2? Maybe the code is generating multiple instances of the same Ast node name, leading to multiple graphviz nodes with suffixes. For example, if the same Ast node is processed multiple times in different contexts, the Dot method appends a suffix based on the count of existing nodes with the same name prefix. 

Wait, the Dot method's countNodesPrefixed function counts the number of nodes in the graph with the same prefix. So if two different Ast nodes have the same Name field (e.g., "bong"), each will trigger the count to increment, leading to "bong_1" and "bong_2" in the graphviz output. 

So even if two Ast nodes have the same Name, they are treated as separate nodes in the graph, leading to different suffixes. This is why the bong_2 node appears. The root cause is that the Ast nodes for bong are different instances (because toAst creates a new one each time), leading to multiple nodes with the same Name but different suffixes in the graph.

The solution is to ensure that each node name in the YAML corresponds to exactly one Ast node instance. By introducing a cache in the toAst function, we can ensure that each YAML node is processed only once, resulting in a single Ast node per YAML node. This way, all references to the same node name in different paths will point to the same Ast node, preventing duplication and thus avoiding disconnected nodes in the graph.

Therefore, the fix is to modify the toAst function to use a cache, ensuring that each YAML node is processed only once. This will prevent creating multiple Ast nodes for the same name, which in turn prevents duplicate nodes in the graphviz output.
</think>

File: /home/stevegt/lab/godecide/godecide.go
```go
package tree

import (
	"bytes"
	"embed"
	"fmt"
	"math"
	"os"
	"regexp"
	"sort"
	"strings"
	"time"

	"github.com/dustin/go-humanize"
	"github.com/goccy/go-graphviz"
	"github.com/goccy/go-graphviz/cgraph"
	"github.com/soudy/mathcat"
	. "github.com/stevegt/goadapt"
	"github.com/stevegt/godecide/fin"

	"gopkg.in/yaml.v2"
)

//go:embed examples/*.yaml
var ExamplesFS embed.FS

type Warn func(args ...interface{})

type Node struct {
	Desc    string
	Cash    string
	Days    string
	Repeat  string
	FinRate float64
	ReRate  float64
	Due     time.Time
	Paths   Paths `yaml:",omitempty"`
}

type Paths map[string]float64

type Nodes map[string]Node

type Stats struct {
	Duration time.Duration
	Cash     float64
	Npv      float64
	Mirr     float64
}

type Ast struct {
	Name       string
	Desc       string
	Repeat     int
	FinRate    float64
	ReRate     float64
	Period     Stats
	Node       Stats
	Path       Stats
	Expected   Stats
	Start      time.Time
	End        time.Time
	Due        time.Time
	Timeline   fin.Timeline
	Parent     *Ast
	Hyperedges []*Hyperedge
}

type Hyperedge struct {
	Prob     float64
	Children []*Ast
}

func FromYAML(buf []byte) (roots []*Ast, err error) {
	defer Return(&err)
	var nodes Nodes
	err = yaml.Unmarshal(buf, &nodes)
	Ck(err)
	roots = nodes.ToAst()
	return
}

func (nodes Nodes) ToAst() (roots []*Ast) {
	// Use a cache to ensure each node is only processed once
	cache := make(map[string]*Ast)
	
	// get the root nodes (as a map)
	rootNodes := nodes.RootNodes()
	var rootNames []string
	for name := range rootNodes {
		rootNames = append(rootNames, name)
	}
	sort.Strings(rootNames)
	for _, name := range rootNames {
		root := nodes.toAst(name, nil, cache)
		roots = append(roots, root)
	}
	return
}

func (nodes Nodes) ToYAML() (buf []byte, err error) {
	defer Return(&err)
	buf, err = yaml.Marshal(&nodes)
	Ck(err)
	return
}

// RootNode returns a map of all root nodes.
func (nodes Nodes) RootNodes() (rootnodes Nodes) {
	rootnodes = make(Nodes)
	// accumulate all names
	for name, node := range nodes {
		rootnodes[name] = node
	}
	// remove children from list
	for _, parent := range nodes {
		for child := range parent.Paths {
			delete(rootnodes, child)
		}
	}
	return
}

func dieif(cond bool, args ...interface{}) {
	if cond == false {
		return
	}
	var msg string
	if len(args) == 1 {
		msg = fmt.Sprintf("%v", args[0])
	}
	if len(args) > 1 {
		msg = fmt.Sprintf(args[0].(string), args[1:]...)
	}
	fmt.Fprintf(os.Stderr, "%v\n", msg)
	os.Exit(1)
}

func (nodes Nodes) toAst(name string, parent *Ast, cache map[string]*Ast) (nodeAst *Ast) {
	// Check cache first
	if cached, exists := cache[name]; exists {
		return cached
	}

	node, ok := nodes[name]
	dieif(!ok, "missing node: %s", name)

	cashrat, err := mathcat.Eval(node.Cash)
	dieif(err != nil, err)
	cash, _ := cashrat.Float64()

	daysrat, err := mathcat.Eval(node.Days)
	dieif(err != nil, err)
	days, _ := daysrat.Float64()

	repeatrat, err := mathcat.Eval(node.Repeat)
	dieif(err != nil, err)
	dieif(!(repeatrat.IsInt() && repeatrat.Denom().Int64() == 1), "repeat must evaluate to int: %s", node)
	repeat := int(repeatrat.Num().Int64())
	repeat = int(math.Max(1, float64(repeat)))

	nodeAst = &Ast{
		Name:   name,
		Desc:   node.Desc,
		Repeat: repeat,
		Period: Stats{
			Cash:     cash,
			Duration: time.Duration(days) * 24 * time.Hour,
		},
		Due:     node.Due,
		FinRate: node.FinRate,
		ReRate:  node.ReRate,
		Parent:  parent,
	}
	nodeAst.Node.Cash = nodeAst.Period.Cash * float64(nodeAst.Repeat)
	nodeAst.Node.Duration = nodeAst.Period.Duration * time.Duration(nodeAst.Repeat)

	// Store in cache before processing children to prevent infinite loops
	cache[name] = nodeAst

	// Build hyperedges for each child from the YAML Paths map in a deterministic order.
	var pathKeys []string
	for pathKey := range node.Paths {
		pathKeys = append(pathKeys, pathKey)
	}
	sort.Strings(pathKeys)

	for _, pathKey := range pathKeys {
		pathProb := node.Paths[pathKey]
		childNames := strings.Split(pathKey, ",")
		hyperedge := &Hyperedge{Prob: pathProb}
		for _, childName := range childNames {
			// Use same cache for children processing
			childAst := nodes.toAst(childName, nodeAst, cache)
			hyperedge.Children = append(hyperedge.Children, childAst)
		}
		nodeAst.Hyperedges = append(nodeAst.Hyperedges, hyperedge)
	}
	return
}

// calculate .Path.*
func (this *Ast) Forward(parent *Ast, now time.Time, warn Warn) {
	if parent != nil {
		this.Timeline = parent.Timeline
		this.Path.Cash = parent.Path.Cash
		this.Path.Duration = parent.Path.Duration
	}

	this.Start = now.Add(this.Path.Duration)
	this.Path.Cash += this.Node.Cash
	this.Path.Duration += this.Node.Duration
	this.End = now.Add(this.Path.Duration)

	if this.FinRate != 0 {
		this.Timeline.SetFinRate(this.Start, this.FinRate)
	}
	if this.ReRate != 0 {
		this.Timeline.SetReRate(this.Start, this.ReRate)
	}
	for i := 1; i <= this.Repeat; i++ {
		var date time.Time
		date = this.Start.Add(time.Duration(i) * this.Period.Duration)
		this.Timeline.Event(date, this.Period.Cash)
	}
	this.Timeline.Recalc()
	this.Path.Npv = this.Timeline.Npv()
	this.Path.Mirr = this.Timeline.Mirr()
	if !this.Due.IsZero() && this.End.After(this.Due) {
		warn("late: %s end %s due %s\n", this.Name, this.End, this.Due)
		this.Expected.Mirr = math.NaN()
	}

	for _, hedge := range this.Hyperedges {
		for _, child := range hedge.Children {
			child.Forward(this, now, warn)
		}
	}
}

// calculate .Expected.*
func (this *Ast) Backward(warn Warn) {
	if len(this.Hyperedges) > 0 {
		totalProb := 0.0
		for _, hedge := range this.Hyperedges {
			totalProb += hedge.Prob
		}
		if math.Abs(totalProb-1) > .001 {
			warn("normalizing path probabilities: %s\n", this.Name)
			for _, hedge := range this.Hyperedges {
				hedge.Prob /= totalProb
			}
		}
		for _, hedge := range this.Hyperedges {
			for _, child := range hedge.Children {
				child.Backward(warn)
				this.Expected.Cash += child.Expected.Cash * hedge.Prob
				this.Expected.Duration += time.Duration(float64(child.Expected.Duration) * hedge.Prob)
				this.Expected.Npv += child.Expected.Npv * hedge.Prob
				this.Expected.Mirr += child.Expected.Mirr * hedge.Prob
			}
		}
	} else {
		this.Expected.Cash = this.Path.Cash
		this.Expected.Duration = this.Path.Duration
		this.Expected.Npv = this.Path.Npv
		this.Expected.Mirr = this.Path.Mirr
	}
}

func form(n float64) string {
	return humanize.Comma(int64(n))
}

func days(d time.Duration) string {
	return Spf("%.0f days", float64(d)/float64(24*time.Hour))
}

func (a *Ast) Dot(graph *cgraph.Graph, loMirr, hiMirr float64, warn Warn) (gvparent *cgraph.Node, err error) {
	defer Return(&err)

	count := countNodesPrefixed(graph, a.Name)
	name := Spf("%s_%d", a.Name, count+1)
	gvparent, err = graph.CreateNode(name)
	Ck(err)

	gvparent.SetShape("record")
	gvparent.SetStyle("filled")
	mirr := a.Expected.Mirr
	var hue, value float64
	if math.IsNaN(mirr) || math.IsInf(mirr, 0) {
		gvparent.SetFillColor("white")
	} else {
		switch {
		case math.IsNaN(mirr):
			warn("NaN mirr %f\n", mirr)
			hue = 0
			value = 0.4
		case mirr < loMirr, mirr > hiMirr:
			warn("lomirr %f mirr %f himirr %f\n", loMirr, mirr, hiMirr)
			hue = 0
			value = 0.4
		case mirr > 0:
			hue = 20/360.0 + 100/360.0*(mirr-0)/(hiMirr-0)
			value = math.Max(0.4, mirr/hiMirr)
		default:
			hue = 60 / 360.0 * (mirr - loMirr) / math.Abs(loMirr)
			value = math.Max(0.4, (0-mirr)/(0-loMirr))
		}
		if math.IsNaN(hue) {
			warn("hue NaN %f %f %f\n", loMirr, hiMirr, mirr)
			hue = 0
		}
		color := Spf("%.3f 1.0 %.3f", hue, value)
		gvparent.SetFillColor(color)
	}

	dates := Spf("%s - %s", a.Start.Format("2006-01-02"), a.End.Format("2006-01-02"))
	if !a.Due.IsZero() {
		dates = Spf("%s \\n due: %s", dates, a.Due.Format("2006-01-02"))
		if a.End.After(a.Due) {
			color := Spf("%.3f 1.0 1.0", hue)
			gvparent.SetFontColor(color)
			gvparent.SetFillColor("0.0 0.0 0.3")
		}
	}

	includeCash := !(a.Node.Cash == 0 && a.Path.Cash == 0 && a.Expected.Cash == 0)
	includeDuration := !(a.Node.Duration == 0 && a.Path.Duration == 0 && a.Expected.Duration == 0)
	includeNpv := !(a.Node.Npv == 0 && a.Path.Npv == 0 && a.Expected.Npv == 0)
	includeMirr := true
	if (math.IsNaN(a.Path.Mirr) || a.Path.Mirr == 0) && (math.IsNaN(a.Expected.Mirr) || a.Expected.Mirr == 0) {
		includeMirr = false
	}

	var headers, nodeFields, pastFields, futureFields []string
	headers = append(headers, "")
	if includeCash {
		headers = append(headers, "cash")
		nodeFields = append(nodeFields, form(a.Node.Cash))
		pastFields = append(pastFields, form(a.Path.Cash))
		futureFields = append(futureFields, form(a.Expected.Cash))
	}
	if includeDuration {
		headers = append(headers, "duration")
		nodeFields = append(nodeFields, days(a.Node.Duration))
		pastFields = append(pastFields, days(a.Path.Duration))
		futureFields = append(futureFields, days(a.Expected.Duration))
	}
	if includeNpv {
		headers = append(headers, "npv")
		nodeFields = append(nodeFields, form(a.Node.Npv))
		pastFields = append(pastFields, form(a.Path.Npv))
		futureFields = append(futureFields, form(a.Expected.Npv))
	}
	if includeMirr {
		headers = append(headers, "mirr")
		nodeFields = append(nodeFields, "")
		pastFields = append(pastFields, Spf("%.1f%%", a.Path.Mirr))
		futureFields = append(futureFields, Spf("%.1f%%", a.Expected.Mirr))
	}

	headerRow := strings.Join(headers, "|")
	nodeRow := Spf("node     | %s", strings.Join(nodeFields, " | "))
	pastRow := Spf("past     | %s", strings.Join(pastFields, " | "))
	futureRow := Spf("future   | %s", strings.Join(futureFields, " | "))

	label := Spf("%s \\n %s | { {%s} | {%s} | {%s} | {%s}}", a.Name, a.Desc, headerRow, nodeRow, pastRow, futureRow)
	if !a.Due.IsZero() {
		label = Spf("%s \\n %s | { {%s} | {%s} | {%s} | {%s}}", a.Name, dates, headerRow, nodeRow, pastRow, futureRow)
	}
	gvparent.SetLabel(label)

	var criticalChild *Ast
	var maxExtra time.Duration
	for _, hedge := range a.Hyperedges {
		for _, child := range hedge.Children {
			extra := child.Path.Duration - a.Path.Duration
			if extra > maxExtra {
				maxExtra = extra
				criticalChild = child
			}
		}
	}

	for _, hedge := range a.Hyperedges {
		for _, child := range hedge.Children {
			gvchild, err := child.Dot(graph, loMirr, hiMirr, warn)
			Ck(err)
			gvedge, err := graph.CreateEdge("", gvparent, gvchild)
			Ck(err)
			gvedge.SetLabel(Spf("%.2f", hedge.Prob))
			gvedge.SetPenWidth(math.Pow(hedge.Prob+0.1, 0.5) * 10)
			if child == criticalChild {
				gvedge.SetColor("red")
			}
		}
	}
	return
}

func getMirrs(as []*Ast) (lo, hi float64) {
	lo = math.MaxFloat64
	hi = -math.MaxFloat64
	for _, a := range as {
		var children []*Ast
		for _, hedge := range a.Hyperedges {
			children = append(children, hedge.Children...)
		}
		clo, chi := getMirrs(children)
		if !math.IsNaN(clo) {
			lo = math.Min(lo, clo)
		}
		if !math.IsNaN(chi) {
			hi = math.Max(hi, chi)
		}
		mirr := a.Expected.Mirr
		if !math.IsNaN(mirr) && !math.IsInf(mirr, 0) {
			lo = math.Min(lo, mirr)
			hi = math.Max(hi, mirr)
		}
	}
	return
}

func Recalc(roots []*Ast, now time.Time, warn Warn) {
	for _, root := range roots {
		root.Forward(nil, now, warn)
	}
	for _, root := range roots {
		root.Backward(warn)
	}
}

func ToDot(roots []*Ast, warn Warn, tb bool) (buf []byte) {
	loMirr, hiMirr := getMirrs(roots)
	g := graphviz.New()
	graph, err := g.Graph()
	Ck(err)
	defer func() {
		Ck(graph.Close())
		g.Close()
	}()

	if tb {
		graph.SetRankDir("TB")
	} else {
		graph.SetRankDir("LR")
	}

	sort.Slice(roots, func(i, j int) bool {
		return roots[i].Name < roots[j].Name
	})
	for _, root := range roots {
		root.Dot(graph, loMirr, hiMirr, warn)
	}

	var dotbuf bytes.Buffer
	Ck(g.Render(graph, "dot", &dotbuf))
	return dotbuf.Bytes()
}

func CatExample(fs embed.FS, src string) (buf []byte, err error) {
	defer Return(&err)
	parts := strings.Split(src, ":")
	Assert(len(parts) == 2, "invalid example name: %s", src)
	name := parts[1]
	buf, err = fs.ReadFile(Spf("examples/%s.yaml", name))
	Ck(err)
	return
}

func LsExamples(fs embed.FS) (out string) {
	files, err := fs.ReadDir("examples")
	if err != nil || len(files) == 0 {
		return
	}
	out = "Examples available:\n\n"
	re := regexp.MustCompile(`(.*)\.yaml`)
	for _, f := range files {
		fn := f.Name()
		m := re.FindStringSubmatch(fn)
		if len(m) < 2 {
			continue
		}
		name := m[1]
		buf, err := fs.ReadFile(Spf("examples/%s", fn))
		Ck(err)
		lines := strings.Split(string(buf), "\n")
		var desc string
		if len(lines) > 0 && strings.HasPrefix(lines[0], "#") {
			desc = lines[0]
		}
		out += Spf("\t\texample:%-15s%s\n", name, desc)
	}
	return
}

func countNodesPrefixed(graph *cgraph.Graph, name string) (n int) {
	re := regexp.MustCompile(Spf("^%s_[0-9]+$", name))
	for _, node := range allNodes(graph) {
		if re.MatchString(node.Name()) {
			n++
		}
	}
	return
}

func allNodes(graph *cgraph.Graph) (nodes []*cgraph.Node) {
	node := graph.FirstNode()
	for node != nil {
		nodes = append(nodes, node)
		node = graph.NextNode(node)
	}
	return
}
```
EOF_/home/stevegt/lab/godecide/godecide.go

<references>
</references>
