The problem is that if a node’s due date is in the past then Forward
sets its expected MIRR to NaN. Later when Dot is trying to determine
color (and asserting that MIRR lies between loMirr and hiMirr),
comparing NaN always fails. In other words, the dot generation code
isn’t ready to handle a NaN MIRR value, so it fails (via the Assert
calls).

A simple fix is to have Dot check for NaN (or Inf) before performing
the assertions and, if found, use default colors (or a “late” color)
without trying to normalize the value. For example, you can change the
beginning of Dot so that the assertions and hue calculations are done
only when Expected.Mirr is a real number.

Below is the modified version of the Dot method where we check if mirr
is NaN or Inf before doing the assertions. (Other parts of the code
remain the same.)

------------------------------------------------------------
package tree

// Dot adds a record-shaped node to the graphviz graph for Ast node a
// (parent), and adds a graphviz edge from a to each of the children
// of a.
func (a *Ast) Dot(graph *cgraph.Graph, loMirr, hiMirr float64, warn Warn) (gvparent *cgraph.Node, err error) {
	defer Return(&err)

	fmt.Fprintf(os.Stderr, "Dot %s\n", a.Name)

	gvparent, err = graph.CreateNode(Spf("%p", a))
	Ck(err)

	gvparent.SetShape("record")
	gvparent.SetStyle("filled")

	mirr := a.Expected.Mirr
	var hue, value float64
	if math.IsNaN(mirr) || math.IsInf(mirr, 0) {
		// For nodes with an invalid MIRR, simply use a default color.
		gvparent.SetFillColor("white")
	} else {
		Assert(mirr >= loMirr, mirr)
		Assert(mirr <= hiMirr, mirr)
		if mirr > 0 {
			hue = 20/360.0 + 100/360.0*(mirr-0)/(hiMirr-0)
			value = math.Max(0.4, mirr/hiMirr)
		} else {
			hue = 60/360.0 * (mirr - loMirr) / math.Abs(loMirr)
			value = math.Max(0.4, (0-mirr)/(0-loMirr))
		}
		if math.IsNaN(hue) {
			warn("hue NaN %f %f %f\n", loMirr, hiMirr, mirr)
			hue = 0
		}
		color := Spf("%.3f 1.0 %.3f", hue, value)
		gvparent.SetFillColor(color)
	}

	dates := Spf("%s - %s", a.Start.Format("2006-01-02"), a.End.Format("2006-01-02"))
	if !a.Due.IsZero() {
		dates = Spf("%s \\n due: %s", dates, a.Due.Format("2006-01-02"))
		if a.End.After(a.Due) {
			color := Spf("%.3f 1.0 1.0", hue)
			gvparent.SetFontColor(color)
			gvparent.SetFillColor("0.0 0.0 0.3")
		}
	}

	// row headings
	head := "             |cash|duration|npv    |mirr  "

	// columns
	n := a.Node
	p := a.Path
	e := a.Expected
	node := Spf("node     | %s | %s     | %s    |      ", form(n.Cash), days(n.Duration), form(n.Npv))
	path := Spf("past     | %s | %s     | %s    |%.1f%% ", form(p.Cash), days(p.Duration), form(p.Npv), p.Mirr)
	expe := Spf("future   | %s | %s     | %s    |%.1f%% ", form(e.Cash), days(e.Duration), form(e.Npv), e.Mirr)

	// put it all together
	label := Spf("%s \\n %s \\n %s | { {%s} | {%s} | {%s} | {%s}}", a.Name, a.Desc, dates, head, node, path, expe)
	gvparent.SetLabel(label)
	for _, child := range a.Children {
		gvchild, err := child.Dot(graph, loMirr, hiMirr, warn)
		Ck(err)
		edge, err := graph.CreateEdge("", gvparent, gvchild)
		Ck(err)
		edge.SetLabel(Spf("%.2f", child.Prob))
		edge.SetPenWidth(math.Pow(child.Prob+.1, .5)*10)
	}
	return
}

------------------------------------------------------------

With this change, if a node’s timeline is late (and Expected.Mirr is NaN), then the dot function simply skips the MIRR normalization and uses default colors. This prevents the assertion failure and allows the graph to be generated, while still issuing a warning that the node is late.

An alternative fix would be to change the behavior in Forward so that a late node gets a “sentinel” MIRR value (say 0 or a flag value) instead of NaN, and then decorate the output accordingly. Either way, the idea is to avoid comparing NaN values when generating the graph.
