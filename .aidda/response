One good solution is to sort the keys (both for selecting the roots and for iterating over a node’s children) before constructing the AST and its hyperedges. In other words, rather than relying on Go’s random map iteration order, you gather the keys into a slice, sort it (using sort.Strings), and then iterate over those keys. This guarantees that the DOT output is built in a deterministic order and will match the expected test files.

Below are the two changes in godecide.go. (Note that you must import "sort" at the top if it isn’t already imported.)

–––––– In the Nodes.ToAst method:
Replace the existing code:
  func (nodes Nodes) ToAst() (roots []*Ast) {
     for name := range nodes.RootNodes() {
        root := nodes.toAst(name, nil)
        roots = append(roots, root)
     }
     return
  }
with this modified version that sorts the keys:
  func (nodes Nodes) ToAst() (roots []*Ast) {
     // get the root nodes (as a map)
     rootNodes := nodes.RootNodes()
     var rootNames []string
     for name := range rootNodes {
        rootNames = append(rootNames, name)
     }
     sort.Strings(rootNames)
     for _, name := range rootNames {
        root := nodes.toAst(name, nil)
        roots = append(roots, root)
     }
     return
  }

–––––– In the nodes.toAst method:
Replace the loop that iterates over node.Paths:
    // Build hyperedges for each child from the YAML Paths map.
    for childname, childProb := range node.Paths {
        childAst := nodes.toAst(childname, nodeAst)
        nodeAst.Hyperedges = append(nodeAst.Hyperedges, &Hyperedge{
            Prob:     childProb,
            Children: []*Ast{childAst},
        })
    }
with this version that sorts the child keys first:
    // Build hyperedges for each child from the YAML Paths map in a deterministic order.
    var childNames []string
    for child := range node.Paths {
        childNames = append(childNames, child)
    }
    sort.Strings(childNames)
    for _, childname := range childNames {
        childProb := node.Paths[childname]
        childAst := nodes.toAst(childname, nodeAst)
        nodeAst.Hyperedges = append(nodeAst.Hyperedges, &Hyperedge{
            Prob:     childProb,
            Children: []*Ast{childAst},
        })
    }

With these changes the DOT generation becomes deterministic and your expected output tests should pass.